package collections;

import java.util.HashMap;
import java.util.Map;

/**
 * 1. Hashing is fundamental concept in computer science. 
 * 2. Hashing algorithms are one-way functions used to verify integrity of data.
 * 3. A hash function takes input of any length and produces a fixed-length string (sometimes called 'digest').
 * 4. A hash function that transforms data in such a way that, given a hash result (digest), it is computatinally
 *      infeasible to produce original message.
 * 5. Hashes are like a fingerprint for the original data. If the data changes, the fingerprint will no longer match.
 * 6. Common hashing algorithms are MD5, SHA-1, SHA-256, SHA-384, SHA-512
 * 7. In Java, efficient hashing algorithms used in HashMap and HashSet.
 * 8. In Java, hashCode() returns an integer value (digest) generated by a hashing algorithm.
 * 9. Objects that are equal (their equals() implementation) must return the same hash code.
 * 10. All the implementations utilize prime number 31 in some form. This is because 31 has a nice property. 
 *      Its multiplication can be replaced by a bitwise shift, which is faster than the standard multiplication.
 *      Ex. 31 * i == (i << 5) - i
 *      IntelliJ, Eclipse also uses 31 in their hashcode generation code snippets.
 * 11. java.util.Objects.hash() can also be used to generate hash code. Objects class introduced in Java 7.
 *      Lombok, Apache-commons HashcodeBuilder are also used to generate hashcode implementation.
 * 12. If we don't override hashCode(), HashMap and HashSet uses 'system generated hash code'.
 * 13. Hash collision: Hash collision happens when two or more objects might have the same hash code even if 
 *      they're unequal. Hash collision strategies are separate chaining, open addressing (linear probing,
 *      quadratic probing), double hashing.
 * 
 *  
 */
public class HashCoding {
   public static void main(String[] args) {
    Map<HashUser, HashUser> users = new HashMap<>();
    HashUser user1 = new HashUser(1L, "Albert", "albert@gmail.com");
    HashUser user2 = new HashUser(2L, "Edward", "edward@gmail.com");
    HashUser user3 = new HashUser(3L, "Mary", "mary@gmail.com");

    users.put(user1, user1);
    users.put(user2, user2);
    users.put(user3, user3);

    if (users.containsKey(user1)) {
        System.out.println("User found in the collection");
    }
   }


}

class HashUser {
    private long id;
    private String name;
    private String email;

    
    public HashUser(long id, String name, String email) {
        this.id = id;
        this.name = name;
        this.email = email;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((email == null) ? 0 : email.hashCode());
        result = prime * result + (int) (id ^ (id >>> 32));
        result = prime * result + ((name == null) ? 0 : name.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        HashUser other = (HashUser) obj;
        if (email == null) {
            if (other.email != null)
                return false;
        } else if (!email.equals(other.email))
            return false;
        if (id != other.id)
            return false;
        if (name == null) {
            if (other.name != null)
                return false;
        } else if (!name.equals(other.name))
            return false;
        return true;
    }
}